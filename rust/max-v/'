
use crate::*;

pub enum FuseLocation {
    //Absolute {
    //    fuse: usize,
    //},
    Strip {
        row: usize,
        column: usize, // 0..2
    },
    Head {
        x: usize,
        sector: usize,
        index: usize, // 0..10
    },
    Global {
        x: usize,
        sector: usize,
    },
    Block {
        x: usize,
        y: usize,
        sector: usize,
        index: usize, // 0..5
    },
    Cell {
        x: usize,
        y: usize,
        sector: usize,
        n: usize, // 0..9
        index: usize, // 0..3
    },
    Tail {
        x: usize,
        sector: usize,
        index: usize, // 0..10
    },
}

impl FuseLocation {
    pub (crate) fn to_index(self, device: &Device)
        -> Result<usize, FuseOutOfRange>
    {
        match self {
            FuseLocation::Tail { x, sector, index: index @ 0..11 } => {
                let sector = sector_at(x, sector, device)?;
                let index = 1 + (sector.rows * 46) + 10 - index;
                Ok(sector.base + sector_sync(index, device.sync_width)
            }

            FuseLocation::Tail { index, .. } =>
                Err(FuseOutOfRange::Tail(index)),

            _ =>
                Err(FuseOutOfRange::Unimplemented),
        }
    }
}

struct Sector {
    base: usize,
    rows: usize,
    global: usize,
}

fn sector_at(x: usize, sector: usize, device: &Device)
    -> Result<Sector, FuseOutOfRange>
{
    if x < device.left_io {
        return Err(FuseOutOfRange::X(x));
    }
    if x > device.right_io {
        return Err(FuseOutOfRange::X(x));
    }

    let base = device.sync_width;
    if x == device.left_io {

    }

    todo!()
}

fn sector_sync(index: usize, sync_width: usize) -> usize {
    let line = i + index.div_euclid(sync_width - 3);
    index + (line * 3)
}

